# Lecture 11

## 快速傅立叶变换

首先考虑2点DFT：

\[ X(k) = \sum_{n=0}^1 x(n)W_2^{nk} = x(0)W_2^{0k} + x(1)W_2^{1k} \]

因此：

\[ \begin{cases}
X(0) &= x(0) + x(1) \\
X(1) &= x(0) - x(1)
\end{cases} \]

我们发现2点DFT只需要做两次加减法即可。

再来看4点DFT：

\[ \begin{align}
X(k) &= \sum_{n=0}^3 x(n)W_4^{nk} \\
&= x(0)W_4^{0k} + x(1)W_4^{1k} + x(2)W_4^{2k} + x(3)W_4^{3k} \\
&= [x(0)+x(2)(-1)^k] + [x(1)+x(3)(-1)^k]W_4^{1k} \\
&= [x_e(0)+x_e(1)(-1)^k] + [x_o(0)+x_o(1)(-1)^k]W_4^{1k}
\end{align} \]

其中\(x_e,x_o\)代表偶数位置和奇数位置的项：\(x_e(n)=x(2n), x_o(n)=x(2n+1)\)。

我们发现，4点DFT实际上是两个2点DFT的线性组合。对于8点DFT也存在这样的性质：

\[ \mathbf{DFT}_8[x(n)] = \mathbf{DFT}_4[x_e(n)] + W_8^{1k}\mathbf{DFT}_4[x_o(n)] \]

将原来的\(N\)点DFT分解为\(M=2^m\)个短DFT，这样的分解后的总DFT复杂度为\(M(\frac{N}{M})^2=\frac{N^2}{M}\)，如果\(N\)为2的幂，那么完全分解后得到的最优复杂度为\(N\)，再加上至多\(NM\)次的拼接组合，最终复杂度约为\(N\log_2(N)\)，显著优于原始的\(N^2\)计算方法。这就是快速傅立叶变换FFT的核心思想。

点数为2的幂的DFT被称为**基2FFT**，有两种计算方法，分别为：

- 按时间抽取/DIT/Decimation-In-Time
- 按频率抽取/DIF/Decimation-In-Frequency

### DIT FFT

将原序列拆分为偶序列\(x_1(n)=x(2n)\)和奇序列\(x_2(n)=x(2n+1)\)，设其DFT分别为\(X_1(k),X_2(k)\)。那么原序列的DFT为：

\[ \begin{align}
X(k) &= X_1(k) + W_N^kX_2(k) \\
X(k+\frac{N}{2}) &= X_1(k) - W_N^kX_2(k) \\
&k=0,1,\cdots,\frac{N}{2}-1
\end{align} \]

注意下半段计算时\(X_2\)的符号。这种运算又称蝶形运算。对于长度为\(N=2^M\)的序列，共需要分解为\(MN/2\)个蝶形，\(MN/2\)次复数乘法，\(MN\)次复数加法。

**旋转因子**：第\(m\)级蝶形需要\(2^{m-1}\)个旋转因子，分别为：

\[W_N^r, r=2^{M-m}\cdot i, i=0,1,\cdots 2^{m-1}-1\]

实际上相当于将内层的短DFT的旋转因子都统一到\(W_N\)的形式。

**输入位倒序**：在蝴蝶图上，\(X(k)\)所对应的序列值\(x(k')\)满足\(k'\)为\(k\)的二进制位倒序的关系。如\(k=3=(011)_2\Rightarrow k'=(110)_2=6\)。

### DIF FFT

实际上相当于DIT方法的反相操作，即将原序列分为前后两半，然后通过两个\(N/2\)点DFT分别求出原序列奇偶位置的DFT值。这两种方法互为转置。

## 卷积的快速运算：FFT的应用

经典的线卷积计算方法需要约\(LM\)次乘法运算。我们发现，若圆卷积的点数\(N\geqslant L+M-1\)时，那么圆卷积和线卷积的值是相同的。而我们又知道，序列的圆卷积可以通过IDFT求得，即：

\[ x(n)\ast h(n) = x(n)\circledast h(n) = \mathbf{IDFT}_N[X(k)\cdot H(k)] \]

这样我们就可以充分利用FFT的速度了。

首先我们将\(x(n),h(n)\)补零到长度都为\(N\)，然后分别计算它们的\(N\)点FFT，逐位置相乘后再计算\(N\)点IFFT即可得到圆卷积列表，也就是想要求得的线卷积。

整个过程相当于三次\(N\)点FFT再加上\(N\)次乘法，总乘法数量为\(N+1.5N\log_2N\)。这个算法在两个序列的长度相近且较大时有明显优势，但是若点数较少或某一个序列的点数较少时甚至会适得其反。

## 改进方法

若要充分利用FFT的优势，我们需要尽量保持两个序列的长度相近。但是实际应用中，原信号序列可能很长，卷积核则相对较短。我们可以通过下面两种方式，手动“分割”较长的信号，来优化卷积的求解：

### 重叠相加法

我们直接将较长的\(x(n)\)分割为\(K\)段长\(L\)的序列，使\(x(n)=\sum_{i=0}^{K-1}x_i(n)\)。由于卷积的线性性质，总卷积即为各段分别卷积之和：

\[ y(n) = \sum_{i=0}^{K-1}[h(n)\ast x_i(n)] \]

这个方法在分段时不重叠，进行卷积的时候也不重叠，在最后相加的时候会发生重叠相加。

### 重叠保留法

设\(h(n)\)的长度为\(M\)。我们也可以将\(x(n)\)分为长\(N\)但是重叠\(M-1\)个点的多段\(x_i(n)\)。然后求每一段的**圆卷积**。不过这一次我们直接将分段卷积的前\(M-1\)个点去掉，然后直接拼接即可得到原卷积。
